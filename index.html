<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-http协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/09/http%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2021-09-09T06:19:09.000Z" itemprop="datePublished">2021-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/09/http%E5%8D%8F%E8%AE%AE/">http协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、http协议简介<br>1、http协议简介<br>​    超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的www文件都必须遵守这个标准。设计http最初的目的是为了提供一种发布和接受HTML（超文本标记语言）页面方法。<br>​    http协议在网络osi模型中属于应用层协议，应用层协议除了 HTTP 还有：FTP，<br>SMTP，DNS，RIP，Telnet 等。<br>​    HTTP 协议工作于客户端—服务端架构上。浏览器作为 HTTP 客户端通过 URL(网址) 向<br>HTTP 服务端（即 Web 服务器） 发送请求。<br>2、超文本<br>​    超文本英文名称叫做 Hypertext，我们在浏览器里面看到的网页就是超文本解析而成的，<br>其网页源代码是一系 列 HTML 代码，里面包含了一系列标签，如 img 显示图片，p 指定显<br>示段落等，浏览器解析这些标签后便形成了我们平常看到的网页，而这网页的源代码 HTML<br>就可以称作超文本。<br>例如我们在 Chrome 浏览器里面打开如百度页面，右键点击”查看源代码”，这些源代<br>码都是超文本。<br>3、什么是url<br>​    我们在浏览器的地址栏里输入的网站地址叫做 URL (Uniform Resource Locator，统<br>一资源定位符)。就像每家每 户都有一个门牌地址一样，每个网页也都有一个 Internet 地<br>址（如：<a target="_blank" rel="noopener" href="http://www.baidu.com)./">http://www.baidu.com）。</a><br>当你在浏览器的 地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏<br>览的地址。浏览器通过超文本传输协议(HTTP)， 将 Web 服务器上站点的网页代码提取出<br>来，并翻译成漂亮的网页。<br>4、http功能<br>     HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从服务器传输<br>超文本到本地浏览器的传输协议。<br>    它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本<br>文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br>5、http特点<br>    无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到<br>客户端的应答后， 即断开连接。采用这种方式可以节省传输时间。<br>媒体独立：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可<br>以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 来传输。<br>无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。如果服务<br>器不需要先前信 息，那么它的应答就比较快。但是缺少状态意味着如果后续处理需要前面<br>的信息，则它必须重传，这样可 能导致每次连接传送的数据量增大，此时可以设置缓存。<br>6、http与https的区别<br>    现在在浏览很多网站时，通过浏览器地址栏可以看到有的网站是 https 开头<br>（<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com/</a> ）, 但是 有的是 http 开头（如：<br><a target="_blank" rel="noopener" href="http://www.weather.com.cn/">http://www.weather.com.cn</a> ）这两种有什么区别呢？难道加了 s 就是复数吗？<br>HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，是以<br>安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层（Secure<br>Sockets Layer 安全套接层），简称为 HTTPS。<br>S 其实是 Security 单词的首字母。<br>HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用<br>可以分为两种：<br>（1）. 是建立一个信息安全通道，来保证数据传输的安全。<br>（2）. 确认网站的真实性，凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标<br>志来查看网站认证之 后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。现在越来越多的网站和 APP 都已经向 HTTPS 方向发展。例如：谷歌从 2017 年 1 月推出的 Chrome 56 开始， 对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户“此网页不安全”。<br>7、.http 与 TCP/IP 的特点：<br>    TCP/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协<br>议，主要解决如何包装数据。<br>关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：“我们在传输<br>数据时，可以只使用（传输层） TCP/IP 协议，但是那样的话，如果没有应用层，便无法<br>识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很<br>多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做 传输层协议将它发到网络上。”</p>
<p>二、http的请求<br>    我们在浏览器输入百度首页的地址：<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com/</a> 输入之后浏览器会给<br>我们打开百度首页。<br>实际上这 个过程是浏览器向网站所在的服务器发送了一个 Request，即请求，网站服<br>务器接收到这个 Request 之后进行处 理和解析，然后返回对应的一个 Response，即响<br>应，然后传回给浏览器，Response 里面就包含了页面的源代码<br>等内容，浏览器再对其进行解析便将网页呈现了出来。<br><img src="https://pic.imgdb.cn/item/613b1fcf44eaada739e0b95d.png"><br>列如，使用火狐浏览器，打开百度，查看页面的请求过程。<br>需要详细步骤，点击这边：<br><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/428894531624967852.html">https://zhidao.baidu.com/question/428894531624967852.html</a><br><img src="https://pic.imgdb.cn/item/613b200544eaada739e0fc5d.png"></p>
<ol>
<li>请求的四部分<br> •Request Method: 请求方式<br> •Request URL: 请求链接<br> •Request Headers: 请求头<br> •Request Body: 请求体 </li>
<li>请求方式—抓用户名和密码<br> 请求方式，请求方式常见的有两种类型，GET 和 POST。<br> GET 用于信息获取，而且应该是安全的和幂等的(幂等的的意思就是一个操作不会修改<br> 状态信息，并且每次操作的时候都返回同样的结果。) 从发送请求的角度，GET 请求相当<br> 于我们在数据库中做了查询的操作， 这样的操作不影响数据库本身的数据。<br> POST 表示可能会修改服务器上资源的请求，也相当于在数据库中做了修改的操作，<br> 会影响数据库本身的数据（比如：注册了账户，发了帖子，做了评论，得到了积分等。这种<br> 情况下，资源状态被改变了）。<br> 案例：<br> Get 请求：<br> 在浏览器地址栏输入：<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=appium">https://www.baidu.com/s?wd=appium</a> 并回车，这个其实就是在百度搜 索 appium 这个关键词。URL 中 包含了请求的参数信息，这里参数 wd 就是要搜寻的关键字。</li>
</ol>
<p>POST 请求：<br>    一般来说，网站登录验证的时候，需要提交用户名密码，这里包含了敏感信息，使用<br>GET 方式请求的话密码就会 暴露在 URL 里面，造成密码泄露，所以这里最好以 POST 方<br>式发送。文件的上传时，由于文件内容比较大，也会 选用 POST 方式。比如百度账户登 录，如下图所示：<br>列如：使用火狐浏览器抓用户名和密码<br><img src="https://pic.imgdb.cn/item/613b204f44eaada739e158d0.png"><br>当然你也可以是用 fiddler 来抓包</p>
<ol start="3">
<li><p>请求网址(URL)<br>Request URL<br>就是请求的网址，即统一资源定位符，用 URL 可以唯一确定我们想请<br>求的资源。比如：<br><a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com/</a> </p>
</li>
<li><p>请求头（Request Headers）<br>请求头，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、<br>User-Agent 等，下面将一些 常用的头信息说明如下：<br>Accept，请求报头域，用于指定客户端可接受哪些类型的信息。<br>• Accept-Language，指定客户端可接受的语言类型。<br>• Accept-Encoding，指定客户端可接受的内容编码。<br>• Host，用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关<br>的位置。从 HTTP 1.1 版本开始，Request 必须包含此内容。<br>• Cookie，也常用复数形式 Cookies，是网站为了辨别用户进行 Session 跟踪而储存在 用户本地的数据。<br>Cookies 的主要功能就是维持当前访问会话。<br>• Referer，此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做  相应的处理，如 做来源统计、做防盗链处理等。<br>• User-Agent，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统 及版本、浏览器 及版本等信息。<br>• Content-Type，即 Internet Media Type，互联网媒体类型，也叫做 MIME 类型，在 HTTP 协议消息头 中，使用它来表示具体请求中的媒体类型信息。例如 application/x-www-form-urlencoded 表示表单数 据， text/html 代表 HTML 格式， image/gif 代表 GIF 图片，application/json 代表json文件</p>
</li>
<li><p>请求体<br>即请求体，一般用于 POST 请求中，主要定义向服务器提交的数据类型，而对于 GET<br>请求 Request Body 则为 空。<br>比如在登录之前我们填写了用户名和密码信息，提交时就这些内容就会以 Form<br>Data 的形式提交给服务器，此时注意 Request Headers 中指定了 Content-Type 为<br>application/x-www-form-urlencoded。<br>Postman看<br>只有设 置 Content-Type 为 application/x-www-form-urlencoded 才会以 Form Data 形式提交，另外我们也可以 将 Content-Type 设置为 application/json 来 提交 Json 数据，或者设置为 multipart/form-data 来上传文件。</p>
</li>
</ol>
<p>常用 Content-Type 和 POST 提交数据方式的关系：<br><img src="https://pic.imgdb.cn/item/613b20b444eaada739e1dc86.png"></p>
<p>三、http的响应<br>1.响应的三部分<br>上述内容讲述的 http 协议的请求，接着描述 http 协议的响应。<br>Response，即响应，由服务端返回给客户端。Response 可以划分为三部分:<br>• Response Status Code ：响应状态码<br>• Response Headers ：响应头<br>• Response Body ：响应提<br>Response Status Code测试系列课程——新睿教学部<br>响应状态码，此状态码表示了服务器的响应状态，如 200 则代表服务器正常响应，404<br>则代表页面未找到，500 则 代表服务器内部发生错误。常用响应状态码如下：<br>可以参考完整的 http 协议的响应状态码：<br><a target="_blank" rel="noopener" href="https://tool.oschina.net/commons?type=5">https://tool.oschina.net/commons?type=5</a><br>1XX： 请求未完成<br>2XX:  表示响应成功<br>3XX：表示转发/重定向<br>4XX: 路径找不到<br>5XX：服务器内部资源错误<br>2. 响应头<br>响应头，其中包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie<br>等，下面将一些常用的头信息说明如下：<br>Date，标识 Response 产生的时间。<br>Last-Modified，指定资源的最后修改时间。<br>Content-Encoding，指定 Response 内容的编码。<br>• Server，包含了服务器的信息，名称，版本号等。<br>• Content-Type，文档类型，指定了返回的数据类型是什么，如<br>text/html 则代表返回 HTML 文档， application/x-javascript 则代表返回 JavaScript<br>文件，image/jpeg 则<br>代表返回了图片。<br>• Set-Cookie，设置 Cookie，Response Headers 中的 Set-Cookie 即告诉浏览器需要<br>将此内容放在 Cookies 中，下次请求携带 Cookies 内容。<br>• Expires，指定 Response 的过期时间，使用它可以控制代理服务器或浏览器将内容更<br>新到缓存中，如果再 次访问时，直接从缓存中加载，降低服务器负载，缩短加载时间。<br>3. 响应体<br>即响应体，响应的正文数据都是在响应体中，如请求一个网页，它的响应体就是网页的<br>HTML 代码，请求一张图 片，它的响应体就是图片的二进制数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/09/http%E5%8D%8F%E8%AE%AE/" data-id="cktcs18w50000mgqdhm8z2itr" data-title="http协议" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-web理论和网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/08/web%E7%90%86%E8%AE%BA%E5%92%8C%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2021-09-08T08:35:44.000Z" itemprop="datePublished">2021-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/08/web%E7%90%86%E8%AE%BA%E5%92%8C%E7%BD%91%E7%BB%9C/">web理论和网络</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、协议</p>
<p>​    数据通信协议的定义：决定数据的格式和传输的一组规则或者一组惯例</p>
<p>二、OSI模型、TCP/IP模型</p>
<p>​    1、 OSI是Open System Interconnection的缩写，意为开放式系统互联。</p>
<p>​        国际标准化组织（ISO）制定了OSI模型。这个模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络        层、传输层、会话层、表示层和应用层。</p>
<p><img src="https://pic.imgdb.cn/item/6138774e44eaada739ed2c46.png"></p>
<pre><code>2、TCP/IP协议：TCP/IP是20世纪70年代中期美国国防部为ARPANET开发的网络体系结构
</code></pre>
<img src="https://pic.imgdb.cn/item/613877f744eaada739ee42ba.png" style="zoom:80%;" />                    

<p>​    3、TCP/IP与OSI模型的比较：</p>
<pre><code>     相同：两者都是以协议栈的概念为基础、协议栈中的协议批次互相独立、下层对上层服务
</code></pre>
<p>​        不同：OSI是先有模型，TCP/IP是先有协议后有模型</p>
<p>​        OSI适用于各种协议栈；TCP/IP只适用于TCP/IP网络</p>
<p>​        层次数量不同<br>​    4、TCP/IP 体系中的传输层<br>​        （1）、用户数据报协议UDP    (User Datagram Protocol)<br>​        （2）、传输控制协议TCP    (Transmission Control Protocol)<br>​    5、用三次握手建立TCP连接<br><img src="https://pic.imgdb.cn/item/61387a8644eaada739f2d22a.png"><br>​      用四次握手结束连接<br><img src="https://pic.imgdb.cn/item/61387b3144eaada739f40ddf.png"><br>三、端口<br>​    端口就是运输层服务访问点(TSAP)。<br>​    端口的作用就是让应用层的各种应用进程都能将其数据通过端口向下交付给运输层，以及让运     输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。<br>​    从这个意义上讲，端口是用来标志应用层的进程<br>四、ip地址</p>
<p>​    IP地址是一种层次结构的地址，它的组成如下：<br>​       网络号+主机号<br>​       网络号确定计算机所在的网络，主机号确定计算机在该网络中的所处的位置。在INTERNET网            中，根据TCP/IP协议规定，每个IP地址是由32bit的二进制数组成的。主要分为三类：<br><img src="https://pic.imgdb.cn/item/613880f244eaada739fe12ea.png"><br>五、DNS基本概念<br>Name Server（域名服务器） ：域名服务器有两大类型Authoritative Name Server    （权威域名  服务器）和Caching Name Server（存储缓冲域名服务器）。权威域名服务器又包含了主服务        器、辅服务器等子类型。<br>The Primary Master（主服务器） / Slave Server（辅服务器） ：每个区至少有一值台权威域名服务器负责解析工作，考虑到服务器和网络的不稳定性，通常把区交由两台或多台权威域名服务器解析。其中的一台被指定为主服务器，其它的则为辅服务器。区完整的配置信息保存在主服务器上，辅服务器会定期将主服务器上区的资料复制到本机。<br>存储缓冲域名服务器 ：为了节省查询时间，提高性能，支持递归查询的域名服务器通常会在一定的时间范围内将查询结果放入高速缓存，使用这种方式的域名服务器称为存储缓冲域名服务器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/08/web%E7%90%86%E8%AE%BA%E5%92%8C%E7%BD%91%E7%BB%9C/" data-id="cktb9xbca0000soqdh5th8deu" data-title="web理论和网络" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux/linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/07/linux/linux/" class="article-date">
  <time class="dt-published" datetime="2021-09-07T10:27:12.000Z" itemprop="datePublished">2021-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/07/linux/linux/">linux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、什么是linux：<br>    Unix是一个强大的多用户、多任务操作系统。<br>    于1969年在AT&amp;T的贝尔实验室开发。<br>    UNIX的商标权由国际开放标准组织（The Open Group）所有。<br>    UNIX操作系统是商业版，需要收费，价格比Microsoft Windows    正版要贵一些。<br>二、linux主流版本：</p>
<p><img src="https://pic.imgdb.cn/item/61373f2e44eaada739cbfeae.png"></p>
<p>三、linux目录结构</p>
<p><img src="https://pic.imgdb.cn/item/613867f344eaada739d16270.png"></p>
<p>四、linux简单指令</p>
<p>​    1、访问命令：</p>
<p>​            cd    文件夹名    ：访问某个文件夹</p>
<p>​            cd    文件夹1/文件夹2    ：访问联级目录</p>
<p>​            cd    ../    :返回上一级</p>
<p>​            cd    ~    ：返回root登陆界面</p>
<p>​    2、列出当前目录的文件与文件夹</p>
<p>​            ls    ：只列出当前目录下的文件和文件夹的名字</p>
<p>​            ll    ：列出当前目录下的文件夹与文件的名字和信息</p>
<p>​    3、创建文件夹</p>
<p>​            mkdir    文件夹名    ：在当前目录下创建文件夹</p>
<p>​            mkdir    -p    文件夹1/文件夹2/文件夹3    ：在当前目录下创建文件夹1，然后在文件夹1里创建文件夹2，文件夹2里创建文件夹3</p>
<p>​    4、删除</p>
<p>​            rmdir    文件夹名    ：删除空的文件夹</p>
<p>​            rm    文件名    :    询问式删除</p>
<p>​            rm    -rf    ：不询问式删除</p>
<p>​            rm    -rf    *    ：自杀式删除</p>
<p>​            rm    -rf    ./*    ：把当前目录下所有文件信息删除掉</p>
<p>​    5、复制、粘贴</p>
<p>​            cp    源文件    目标文件</p>
<p>​    6、剪切、移动</p>
<p>​            mv    源文件    目标路径（文件夹）</p>
<p>​    7、打包压缩</p>
<p>​    <img src="https://pic.imgdb.cn/item/61386bc144eaada739d81ba8.png"></p>
<p>​            压缩格式：    tar    -czvf    压缩包.gz    ./*</p>
<p>​            解压：tar    -xvf    压缩包名。gz</p>
<p>​    8、vi与vim文件编辑</p>
<p>​            （1）、vi    文件名    ：进入文件视图界面</p>
<p>​            （2）、按下    “i”    键进入编辑界面，往里面输入内容</p>
<p>​            （3）、输入完保存文件内容：①按下：esc    ②按下：”:”    ③    输入：wq    ④按下回车键</p>
<p>​            （4）、不想保存：①从上面第二部开始    ②输入：q！    ③回车</p>
<p>​    Vim和vi指令用法是一样的，最直接的区别就是看代码的时候：</p>
<p>​    Vi：整个字体都是白色</p>
<p>​    Vim：会有其他颜色</p>
<p>​    9、浏览文件</p>
<p>​            （1）、cat：用于显示文件内容</p>
<p>​            （2）、more：一般用于要显示的内容会超过一个画面长度的情况。按空格会显示下一个画面，回车显示下一行内                           容，按    “q”    键退出查看</p>
<p>​            （3）、less：用法和more类似，不同的是less可以通过pgup、pgdn键来控制</p>
<p>​            （4）、tail：用于文件显示后几行的内容：</p>
<p>​                                    用法:</p>
<p>​                                    tail -10 /etc/passwd        查看后10行数据</p>
<p>​                                    tail -f catalina.log      动态查看日志(*****)</p>
<pre><code>                                 ctrl+c 结束查看
</code></pre>
<p>​    10、其它命令：pwd：显示当前所在目录        touch：创建一个空文件</p>
<p>​        </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/07/linux/linux/" data-id="cktb87y6i0001sgqd8fzi8zf5" data-title="linux" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-接口测试/接口测试工具" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/" class="article-date">
  <time class="dt-published" datetime="2021-09-07T10:09:53.000Z" itemprop="datePublished">2021-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/">接口测试工具</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/" data-id="cktb87y6d0000sgqd7lxr11b6" data-title="接口测试工具" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-接口测试/接口测试理论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2021-09-07T10:06:57.000Z" itemprop="datePublished">2021-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/">接口测试理论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>接口测试</p>
<p>一、什么是接口测试<br>接口可以分下面几种</p>
<p>　　1、系统与系统之间的调用，比如银行会提供接口供电子商务网站调用，或者说，支付宝会提供接口给淘宝调用。<br>　　2、上层服务对下层服务的调用，比如service层会调用DAO层的接口，而应用层又会调用服务层提供的接口，一般会通过。<br>　　3、服务之间的调用，比如注册用户时，会先调用用户查询的服务，查看该用户是否已经注册。而我们所要做的接口测试，先要了解是基于哪一种类型的接口测试，不同类型的接口测试方法可能是不一致的，总体来说，不管是那种类型，我们只要把被测接口当做是服务方，而把我们的测试手段当做是客户方，我们的目的就是，通过我们的测试手段，去验证服务端满足了他声明提供的功能。<br>4、至于说到具体的测试方法，http协议的接口测试，一般会用jmeter去测试，jmeter的好处是不用写测试代码，直接使用jmeter提供的http请求去测试，也可以使用HTTPClient去测试，好处是可以方便集成和自动化。java接口的测试，则需要编写测试代码去测试，有点类似于单元测试，但是需要更多的考虑业务场景。</p>
<p>二、接口测试的流程一般是怎么样的？<br>    1、接口测试的流程其实和功能测试的流程类似，因为接口测试依赖的主要对象也是需求说明书，所以，最初的流程就是参与需求讨论，评审需求。<br>　　2、需求确定以后，开发会根据需求进行接口设计，会产出接口定义，在开发设计过程中，有能力的话，可以给出一些针对设计的建议，提高可测性，针对需求及设计，进行测试计划，测试设计，然后还需要和配管确定测试环境相关的事情。<br>　　3、在开发完成接口定义之后，就根据需求文档及接口定义进行测试用例设计，测试用例设计主要从业务场景，功能，以及异常测试几个方面考虑。<br>　　4、测试用例设计完成后，针对测试用例进行评审，然后，如果开发代码部分可测时，即可进入测试了，因为是部分可测，可能会使用到mock方法。<br>5、已有测试代码时，就要进行测试代码的持续集成了，我们是使用hudson来进行持续集成的在项目结束后，会对每个项目进行总结</p>
<p>三、接口测试的数据准备，应该怎么做呢？<br>  接口测试的数据准备，可以从下面几个方面去考虑：<br>　　1、如果是只测试一次的接口，可以使用硬编码的方式准备测试数据，在写测试代码的时候，使用到什么数据就写什么数据，为了避免数据重复，可能比较多的会用到随机字符或随机数<br>　　2、可以直接通过调用其他API的方式准备测试数据，这种情况在测试最上层服务的时候比较有用，比如测试团购购买服务，就需要准备要购买的团购数据，购买团购的用户数据，这个时候，可以直接调用生产团购的api和生成用户的api直接生成测试数据<br>    3、使用excel或xml准备测试数据，这种准备测试数据的方式，主要针对对象数据的准备，比如可以将一条团购数据对应excel中的一条数据，因为一般开发都会使用pojo映射，而在准备测试数据的时候，这些pojo对象属性的设置往往是重复和大工作量的，用excel或XML方式准备，则可以减少在代码当中重复去准备这些数据。<br>4、也可以使用工具方法的形式去准备测试数据，通过在代码中写工具方法去实现数据生成，而在测试代码中调用工具方法去得到所需数据。</p>
<p>四、接口测试怎么设计测试用例呢？<br>接口测试用例的设计方法其实和功能测试用例的设计方法是类似的，因为接口是需要满足需求的，而接口测试所依赖的也是需求说明书，但是，因为接口测试毕竟是通过代码去测试代码，所以，为了保证覆盖率，可能会使用到单元测试的方法，具体的测试用例设计如下：输入参数测试：<br>1、针对输入的参数进行测试，也可以说是假定接口参数的不正确性进行的测试，确保接口对任意类型的输入都做了相应的处理：输入参数合法，输入参数不合法，输入参数为空，输入参数为null，输入参数超长；<br>　　2、功能测试：接口是否满足了所提供的功能，相当于是正常情况测试，如果一个接口功能复杂时推荐对接口用例进行结构划分，这样子用例具有更好的可读性和维护性；<br>　　3、逻辑测试：逻辑测试严格讲应为单元测试，单元测试应保持内部逻辑的正确性，可单元测试和接口测试界限并不是那么清楚，所以我们也可以从给出的设计文档中考虑内部逻辑错误的分支情况和异常；<br>4、异常情况测试：接口实现是否对异常情况都进行了处理，接口输入参数虽然合法，但是在接口实现中，也会出现异常，因为内部的异常不一定是输入的数据造成的，而有可能是其他逻辑造成的，程序需要对任何的异常都进行处理。</p>
<p>五、接口测试盒单元测试有什么区别？接口测试和白盒测试又有什么区别？<br>　　单元测试是针对具体的代码逻辑进行测试，主要测试被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件（或者场景）下某个特定函数的行为。例如，你可能把一个很大的值放入一个有序list 中去，然后确认该值出现在list 的尾部。或者，你可能会从字符串中删除匹配某种模式的字符，然后确认字符串确实不再包含这些字符了。尽量减少这些功能单元集成起来出错的可能性，单元测试一般是由开发人员自己去完成，单元测试可能不会考虑业务是如何的，会更多的考虑，我这个单元模块逻辑是否正确。<br>　　接口测试指的是针对程序内部的或者外部的接口进行的测试，一个接口方法可能会包含多个单元模块，而且，一个接口会有自己特定的业务定义，所以，做接口测试的时候，更多的需要从业务的角度去考虑如何测试这个接口。<br>　　不管是接口测试还是单元测试，其实都属于白盒测试的一个阶段，白盒测试具体的方法有很多种，比如代码审查，比如代码覆盖。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/" data-id="ckt9xpzfs0003xgqda99balg2" data-title="接口测试理论" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-接口测试/接口测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2021-09-07T10:01:42.000Z" itemprop="datePublished">2021-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/">接口测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1、什么是接口：API（Application Programming Interface,应用程序编程接口）是一些预先定义的函 数，目的是提供应用程序与 开发人员基于某软件或硬件得以访问一组例程的能力，而又无 需访问源码，或理解内部工作机制的细节。<br>2、什么是接口测试：接口测试是对系统或组件之间的接口进行测试，主要是校验数据的交换，传递和控制管 理过程，以及相互逻辑依赖 关系。其中接口协议分为 HTTP,WebService,Dubbo,Thrift,Socket 等类型<br>3、接口测试流程：需求分析 -&gt; 用例设计 -&gt; 脚本开发 -&gt; 测试执行 -&gt; 结果分析</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/" data-id="ckt9xpzfr0002xgqdhrksecjc" data-title="接口测试" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mysql/mysql基本操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/07/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2021-09-07T09:11:26.000Z" itemprop="datePublished">2021-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/07/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">mysql基本操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、库操作<br>（1）建库 create      database    数据库名<br>（2）选择库 use    库名<br>（3）删除库 drop    database    数据库名<br>（4）<br>二、表操作<br>（1）建表：先进入库，在创建表<br>    use    库名<br>    create table 表名（字段名1 数据类型 约束，字段名2 数据类型，……）</p>
<pre><code>最后一个字段不要加逗号“，”，约束是非必要的
约束关键字：非空约束：not null
          默认值约束：default
          主键约束：primary key
            唯一约束：unique
            标识列（自动增长）：auto_increment
            外键约束：foreign key
</code></pre>
<p>（2）、插入数据：insert into 表名（值1，值2）插入一条<br>              insert into 表名（值1，值2），（值3，值4），（值5，值6）…;<br>      将表二符合条件的数据插入表一中：<br>      insert into 表一 select * from 表二 where 条件<br>（3）、删除数据：delete from 表名 （只删除数据，不删表结构，标识列不会清零）<br>      truncate （只删数据不删表结构，标识列会清零）<br>      drop （直接删除表结构）<br>    删除一组数据：delete from 表名 where 条件<br>（4）、该数据：update 表名 set 要修改的列=修改的值 where 条件<br>（5）、查数据：一切根源：select * from 表名<br>            逻辑词：and or not<br>            分组：group by、having（分组后再过滤）<br>            正排序：select * from 表名 order by 列名 asc<br>            倒序：    select * from 表名 order by 列名 desc<br>（6）、mysql连接:INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记              录。（select * from t1 inner join t2 on t1.公共列=t2.公共列）<br>              LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记                  录。<br>              RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记                  录，即使左表没有对应匹配的记录。<br>（7）、聚合函数：max最大、min最小、sun求和、avg平均数、count计数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/07/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" data-id="ckt9wiukz0000skqdbcij3akf" data-title="mysql基本操作" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mysql/mysql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/07/mysql/mysql/" class="article-date">
  <time class="dt-published" datetime="2021-09-07T09:08:06.000Z" itemprop="datePublished">2021-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/07/mysql/mysql/">mysql</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、 SQL建表<br>use 数据库; – 先切换到具体的数据库<br>drop table if exists classes; – 判断存在则删除<br>create table classes  – 创建班级表<br>(<br>   CID int not null,<br>   Cname varchar(20) null<br>);</p>
<p>注：<br>1.每条语句后面使用分号结束<br>2.列和列之间使用逗号隔开，最后一列无需逗号<br>3.默认有符号（zerofill），无符号（unsigned）<br>二、 约束<br>约束关键字：<br>  数据类型：省<br>  非空约束：not null<br>  默认值约束：default<br>  检查约束：没有<br>  主键约束：primary key<br>  唯一约束：unique<br>  标识列（自动增长）：auto_increment<br>  外键约束：foreign key</p>
<p>如何添加约束：建表时数据类型后面直接加约束<br>如：<br>Drop table if exists students; – 判断存在则删除<br>create table students<br>(<br>   SID int not null primary key auto_increment,      – 非空 主键 自动增长<br>   Sname varchar(20) null,                             – 允许空<br>   Ssex varchar(2) not null default ’男’,         – 默认’男’<br>   SCard varchar(18) not null unique,                – 唯一<br>   SCID int,<br> foreign key(SCID) references classes(CID)       – 单独加外键<br>);</p>
<p>三、 表的其它操作<br>修改表名：<br>   alter table 旧表名 rename 新表名;<br>修改表结构：<br>   alter table 表名 add 字段名 数据类型 [约束];<br>   alter table 表名 drop 字段名;<br>   alter table 表名 change 旧字段名 新字段名 新数据类型; –修改字段名和数据类型<br>   alter table 表名 modify 字段名 新数据类型;  –只修改字段数据类型</p>
<p>复制表：<br>   仅结构：create table 新表名 like 源表;<br>   结构和数据：create table 新表名 select * from 源表;</p>
<p>课后拓展：创建表之后，能否再添加或删除约束？<br>1.非空约束<br>添加:alter table 表名 modify 列名 数据类型 not null<br>删除:alter table 表名 modify 列名 数据类型 null</p>
<p>2.主键约束<br>添加:alter table 表名 add primary key (字段)<br>删除:alter table 表名 drop primary key</p>
<p>3.唯一约束<br>添加:alter table 表名 add unique 约束名（字段）<br>删除:alter table 表名 drop key 约束名</p>
<p>4.自动增长（需要是主键，才能自动增长）<br>添加:alter table 表名 modify 列名 int primary key auto_increment<br>删除:alter table 表名 modify 列名 int  </p>
<p>5.外键约束<br>添加:alter table 表名 add constraint 约束名 foreign key(外键列)<br>references 主键表（主键列）<br>删除:alter table 表名 drop foreign key 约束名</p>
<p>6.默认值<br>添加:alter table 表名 alter 列名 set default ‘值’<br>删除:alter table 表名 alter 列名 drop default</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/07/mysql/mysql/" data-id="ckt9wf9670001akqdgkkwdlwh" data-title="mysql" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-软件测试基础/软件缺陷" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7/" class="article-date">
  <time class="dt-published" datetime="2021-09-07T08:47:03.000Z" itemprop="datePublished">2021-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7/">软件缺陷</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1、什么是缺陷：软件存在着不符合质量需求或违背软件用户、客户、企业意愿的问题，这就是软件缺陷 （Defect），又叫“Bug（臭虫）”。<br>2、缺陷判断标准：(1)软件未达到产品说明书标明的功能；<br>              （2）软件出现了产品说明书指明不会出现的错误；<br>              （3）软件功能超出产品说明书指明范围；<br>              （4）软件未达到产品说明书虽未指出但应达到的目标；<br>              （5）软件测试员认为软件难以理解、不易使用、运行速度缓慢，或者最终用                  不好。<br>3、表现形式：A.用户要求的功能、特性没有实现或部分实现。<br>        B.运行出错，包括运行中断、系统崩溃、界面混乱等。<br>        C.数据结果不正确、精度不够、不完整或格式不统一。<br>        D.文字显示内容不正确或拼写错误。<br>        E.系统性能低下、系统资源浪费。<br>4、缺陷报告组成：a.缺陷标题 、b.复现步骤 、c.预期结果、d.实际结果 、e.注释截图<br>5、缺陷分类：a、类型分类：功能缺陷、界面缺陷、文档缺陷、代码缺陷、算法错误、性能缺陷<br>             b、等级分类：A 类—致命缺陷，包括以下各种错误：<br>            序所引起的死机，非法退出； <br>            死循环； <br>            数据库发生死锁； <br>            因错误操作导致的程序中断； <br>            功能错误； <br>            与数据库连接错误； <br>            数据通讯错误<br>            B 类—严重缺陷，包括以下各种错误： <br>            程序错误； <br>            程序接口错误； <br>            数据库的表、业务规则、缺省值未加完整性等约束条件<br>            C 类一般缺陷，包括以下各种错误：<br>            操作界面错误（包括数据窗口内列名定义、含义是否一致）； <br>            打印内容、格式错误； <br>            简单的输入限制未放在前台进行控制； <br>            删除操作未给出提示； <br>            数据库表中有过多的空字段<br>            D 类—较小缺陷，包括以下各种错误：<br>             界面不规范；<br>             辅助说明描述不清楚；<br>             输入输出不规范；<br>             长操作未给用户提示；<br>             提示窗口文字未采用行业术语；<br>             可输入区域和只读区域没有明显的区分标志<br>6、缺陷的生命周期：提交缺陷——分配缺陷——处理缺陷——测试通过——关闭缺陷<br>                                         -–不通过—/<br>缺陷处理工具：禅道、jira、bugzilla</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7/" data-id="ckt9upi6b00013cqd5kqw7xm5" data-title="软件缺陷" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-软件测试基础/软件测试入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2021-09-07T08:00:55.000Z" itemprop="datePublished">2021-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/">软件测试入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一、软件工程<br>1、软件工程：系统化、规范化、可管理、将软件开发变成一项工程<br>2、软件开发模型：（1）、瀑布模型    （2）v模型    （3）快速原型模型    （4）迭代模型                      （5）螺旋模型<br>二、软件测试<br>1、软件测试定义：软件测试是使用人工或者自动手段运行或测定某个系统的过程，检验系统是否                  满足规定的需求，并找出预期结果与实际结果的差异。<br>2、软件测试对象：软件测试贯穿整个软件生命周期，所以需求分析、概要设计、以及程序编码等                  各阶段的产物都应作为测试对象<br>3、软件测试目的：（1）预防缺陷，减少产品风险、（2）发现被测对象与用户需求之间的异、                          （3）3)通过测试活动发现并解决缺陷，增加人们对被测对象的质量信心、                          （4）通过测试活动，发现被测对象的质量信息，为决策者提供数据依据；<br>4、软件测试遵循的原则：（1）测试应基于用户需求、（2）测试要尽早进行、（3）穷尽测试是                          不可能的、（4）测试缺陷要符合“二八”定理、（5）没有缺陷的软件                          是不存在的<br>5、测试风险：软件测试中的软件风险分析是根据预测软件将出现的风险，制定软件测试计划并              排列优先等级，风险分析是对软件中潜在的问题进行识别、估计和评价的过程风                      险也包括进度风险、质量风险、人员风险、变更风险、成本风险等<br>6、软件质量：软件与明确的和隐含的定义的需求相一致的程度<br>  软件质量特点：功能性、可靠性、易用性、可维护<br>  影响软件软件质量因素：需求模糊、开发过程不规范、软件开发人员问题、缺乏质量管理<br>7、测试分类：（1）、按照测试阶段划分：单元测试、冒烟测试、集成测试、系统测试、验收测 试<br>          （2）、测试技术分类：黑盒测试、白盒测试、<br>           （3）软件质量分类：功能测试、性能测试<br>           （4）自动化程度：手工测试、自动化测试<br>           （5）测试类型：界面测试、安全性测试、文档测试、<br>           （6）其它：阿尔法测试、贝塔测试、回归测试<br>8、软件测试流程：需求分析、测试计划、测试设计、测试执行、测试评估</p>
<p>9、测试用例组成：用例编号、测试项目、用例名称、重要级别、前置条件、测试数据、操作步骤、预期结果、实际结果</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/07/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/" data-id="ckt9tlj5v000294qd66qlbqy1" data-title="软件测试入门" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/09/http%E5%8D%8F%E8%AE%AE/">http协议</a>
          </li>
        
          <li>
            <a href="/2021/09/08/web%E7%90%86%E8%AE%BA%E5%92%8C%E7%BD%91%E7%BB%9C/">web理论和网络</a>
          </li>
        
          <li>
            <a href="/2021/09/07/linux/linux/">linux</a>
          </li>
        
          <li>
            <a href="/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/">接口测试工具</a>
          </li>
        
          <li>
            <a href="/2021/09/07/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/">接口测试理论</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>